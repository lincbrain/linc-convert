"""
Converts JPEG2000 files generated by MBF-Neurolucida into a OME-ZARR pyramid.

It does not recompute the image pyramid but instead reuse the JPEG2000 levels
(obtained by wavelet transform).
"""

# stdlib
import os

# externals
import glymur
import nibabel as nib
from cyclopts import App

# internals
from linc_convert import utils
from linc_convert.modalities.df.cli import df
from linc_convert.utils.j2k import WrappedJ2K, get_pixelsize
from linc_convert.utils.math import ceildiv
from linc_convert.utils.orientation import center_affine, orientation_to_affine
from linc_convert.utils.zarr import from_config
from linc_convert.utils.zarr.zarr_config import ZarrConfig

ss = App(name="singleslice", help_format="markdown")
df.command(ss)


@ss.default
def convert(
        inp: str,
        *,
        zarr_config: ZarrConfig = None,
        max_load: int = 16384,
        orientation: str = "coronal",
        center: bool = True,
        thickness: float | None = None,
        **kwargs
) -> None:
    """
    Convert a JPEG2000 file generated by MBF-Neurolucida into a Zarr pyramid.

    It does not recompute the image pyramid but instead reuse the JPEG2000
    levels (obtained by wavelet transform).

    Orientation
    -----------
    The anatomical orientation of the slice is given in terms of RAS axes.

    It is a combination of two letters from the set
    `{"L", "R", "A", "P", "I", "S"}`, where

    * the first letter corresponds to the horizontal dimension and
        indicates the anatomical meaning of the _right_ of the jp2 image,
    * the second letter corresponds to the vertical dimension and
        indicates the anatomical meaning of the _bottom_ of the jp2 image.

    We also provide the aliases

    * `"coronal"` == `"LI"`
    * `"axial"` == `"LP"`
    * `"sagittal"` == `"PI"`

    The orientation flag is only useful when converting to nifti-zarr.

    Parameters
    ----------
    inp
        Path to the input JP2 file
    out
        Path to the output Zarr directory [<INP>.ome.zarr]
    max_load
        Maximum input chunk size
    orientation
        Orientation of the slice
    center
        Set RAS[0, 0, 0] at FOV center
    thickness
        Slice thickness
    """
    zarr_config = utils.zarr.zarr_config.update(zarr_config, **kwargs)
    zarr_config.set_default_name(os.path.splitext(inp)[0])
    omz = from_config(zarr_config)

    j2k = glymur.Jp2k(inp)
    vxw, vxh = get_pixelsize(j2k)

    # Write each level
    nblevel = j2k.codestream.segment[2].num_res
    has_channel = j2k.ndim - 2
    for level in range(nblevel):
        subdat = WrappedJ2K(j2k, level=level)
        shape = subdat.shape
        print("Convert level", level, "with shape", shape)
        array = omz.create_array(str(level), shape=shape, zarr_config=zarr_config)

        if max_load is None or (shape[-2] < max_load and shape[-1] < max_load):
            array[...] = subdat[...]
        else:
            ni = ceildiv(shape[-2], max_load)
            nj = ceildiv(shape[-1], max_load)
            for i in range(ni):
                for j in range(nj):
                    print(f"\r{i + 1}/{ni}, {j + 1}/{nj}", end="")
                    array[
                    ...,
                    i * max_load: min((i + 1) * max_load, shape[-2]),
                    j * max_load: min((j + 1) * max_load, shape[-1]),
                    ] = subdat[
                        ...,
                        i * max_load: min((i + 1) * max_load, shape[-2]),
                        j * max_load: min((j + 1) * max_load, shape[-1]),
                        ]
            print("")

    # Write OME-Zarr multiscale metadata
    print("Write metadata")
    axes = ["c", "y", "x"] if has_channel else ["y", "x"]
    omz.write_ome_metadata(axes=axes, space_scale=get_pixelsize(j2k),
                           multiscales_type="jpeg2000")

    if not zarr_config.nii:
        print("done.")
        return

    # Write NIfTI-Zarr header
    # NOTE: we use nifti2 because dimensions typically do not fit in a short
    # TODO: we do not write the json zattrs, but it should be added in
    #       once the nifti-zarr package is released
    shape = list(reversed(omz["0"].shape))
    if has_channel:
        shape = shape[:2] + [1, 1] + shape[2:]
    affine = orientation_to_affine(orientation, vxw, vxh, thickness or 1)
    if center:
        affine = center_affine(affine, shape[:2])
    header = nib.Nifti2Header()
    header.set_data_shape(shape)
    header.set_data_dtype(omz["0"].dtype)
    header.set_qform(affine)
    header.set_sform(affine)
    header.set_xyzt_units(nib.nifti1.unit_codes.code["micron"])
    header.structarr["magic"] = b"n+2\0"

    omz.write_nifti_header(header)
    print("done.")
