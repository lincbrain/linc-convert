"""
Converts JPEG2000 files generated by MBF-Neurolucida into a OME-ZARR pyramid.

It does not recompute the image pyramid but instead reuse the JPEG2000 levels
(obtained by wavelet transform).
"""
import logging

# stdlib
import os

# externals
import glymur
from cyclopts import App

# internals
from linc_convert.modalities.df.cli import df
from linc_convert.utils.io.j2k import WrappedJ2K, get_pixelsize
from linc_convert.utils.io.zarr import from_config
from linc_convert.utils.math import ceildiv
from linc_convert.utils.nifti_header import build_nifti_header
from linc_convert.utils.zarr_config import (
    GeneralConfig,
    NiftiConfig,
    ZarrConfig,
    autoconfig,
)

logger = logging.getLogger(__name__)
ss = App(name="singleslice", help_format="markdown")
df.command(ss)


@ss.default
@autoconfig
def convert(
    inp: str,
    *,
    thickness: float | None = None,
    general_config: GeneralConfig = None,
    zarr_config: ZarrConfig = None,
    nii_config: NiftiConfig = None,
) -> None:
    """
    Convert a JPEG2000 file generated by MBF-Neurolucida into a Zarr pyramid.

    It does not recompute the image pyramid but instead reuse the JPEG2000
    levels (obtained by wavelet transform).


    Parameters
    ----------
    inp
        Path to the input JP2 file
    thickness
        Slice thickness
    general_config
        General configuration
    zarr_config
        Zarr related configuration
    nii_config
        NIfTI header related configuration

    """
    general_config.set_default_name(os.path.splitext(inp)[0])
    omz = from_config(general_config.out, zarr_config)
    max_load = general_config.max_load
    j2k = glymur.Jp2k(inp)
    vxw, vxh = get_pixelsize(j2k)

    # Write each level
    nblevel = j2k.codestream.segment[2].num_res
    has_channel = j2k.ndim - 2
    for level in range(nblevel):
        subdat = WrappedJ2K(j2k, level=level)
        shape = subdat.shape
        print("Convert level", level, "with shape", shape)
        array = omz.create_array(
            str(level), shape=shape, zarr_config=zarr_config, dtype=j2k.dtype
        )

        if max_load is None or (shape[-2] < max_load and shape[-1] < max_load):
            array[...] = subdat[...]
        else:
            ni = ceildiv(shape[-2], max_load)
            nj = ceildiv(shape[-1], max_load)
            for i in range(ni):
                for j in range(nj):
                    print(f"\r{i + 1}/{ni}, {j + 1}/{nj}", end="")
                    array[
                    ...,
                    i * max_load: min((i + 1) * max_load, shape[-2]),
                    j * max_load: min((j + 1) * max_load, shape[-1]),
                    ] = subdat[
                        ...,
                        i * max_load: min((i + 1) * max_load, shape[-2]),
                        j * max_load: min((j + 1) * max_load, shape[-1]),
                        ]
            print("")

    # Write OME-Zarr multiscale metadata
    print("Write metadata")
    axes = ["c", "y", "x"] if has_channel else ["y", "x"]
    omz.write_ome_metadata(
        axes=axes, space_scale=get_pixelsize(j2k), multiscales_type="jpeg2000"
    )

    if nii_config.nii:
        header = build_nifti_header(
            zgroup=omz,
            voxel_size_zyx=tuple([thickness or 1, vxh, vxw]),
            unit="micrometer",
            nii_config=nii_config,
        )
        omz.write_nifti_header(header)

    logger.info("Conversion complete.")
