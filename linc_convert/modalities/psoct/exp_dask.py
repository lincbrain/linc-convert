"""
Matlab to OME-Zarr.

Converts Matlab files generated by the MGH in-house OCT pipeline
into a OME-ZARR pyramid.

WARNING: THIS IS ONLY FOR TESTING IO. NEVER USE FOR PRODUCTION
"""

from typing import Optional
import logging

import cyclopts
import numpy as np
from dask import delayed
from scipy.io import loadmat

from linc_convert import utils
from linc_convert.modalities.psoct.cli import psoct
from linc_convert.utils.zarr import open_zarr_group, create_array
import dask.array as da

from linc_convert.utils.zarr.zarr_config import ZarrConfig

logger = logging.getLogger(__name__)
exp_dask = cyclopts.App(name="exp_dask", help_format="markdown")
psoct.command(exp_dask)

@delayed
def load_mat_array(file, key):
    return loadmat(file)[key]

@exp_dask.default
def convert(
    inp: list[str],
    *,
    zarr_config: ZarrConfig = None,
    key: Optional[str] = None,
    meta: str = None,
    orientation: str = "RAS",
    center: bool = True,
    dtype: Optional[str] = None,
    store: bool = True,
    **kwargs
) -> None:
    """
    Matlab to OME-Zarr.

    Convert OCT volumes in raw matlab files into a pyramidal
    OME-ZARR (or NIfTI-Zarr) hierarchy.

    This command assumes that each slice in a volume is stored in a
    different mat file. All slices must have the same shape and will be
    concatenated into a 3D Zarr.

    Parameters
    ----------
    inp : list of str
        Paths to the input mat files.
    key : Optional[str]
        Key of the array to be extracted; defaults to the first key found.
    meta : str
        Path to the metadata file.
    orientation : str
        Orientation of the volume.
    center : bool
        Set RAS[0, 0, 0] at FOV center.
    dtype : Optional[str]
        Data type to write into.
    """
    zarr_config = utils.zarr.zarr_config.update(zarr_config, **kwargs)
    vx = [1, 1, 1]
    unit = "um"
    logger.info("start")
    # Prepare Zarr group
    omz = open_zarr_group(zarr_config)

    dtype = np.float32
    nslices = len(inp)
    data = [load_mat_array(inp[i], "R3D") for i in range(nslices)]

    slices = [da.from_delayed(i, shape=(350,350,1000), dtype=dtype) for i in data]
    nested = np.array([None]*80, dtype=object)
    for i in range(80):
        nested[i] = slices[i]
    nested=nested.reshape((4, 4, 5))
    # Convert the numpy array into a nested list
    nested_list = nested.tolist()

    # Now concatenate the rows vertically
    full_volume = da.block(nested_list)
    print(full_volume.shape)

    dataset = create_array(omz, "0", shape=full_volume.shape, zarr_config=zarr_config,
                           dtype=np.dtype(dtype))
    if dataset.shards is None:
        full_volume.to_zarr(dataset)
    else:
        full_volume = full_volume.rechunk(dataset.shards)
        if store:
            full_volume.store(dataset)
        else:
            def save(chunk,block_info=None):
                slicer = tuple(slice(*al) for al in block_info[0]['array-location'])
                dataset[slicer] = chunk
                return 0
            full_volume.map_blocks(save, dtype=np.uint8).compute()


    # generate_pyramid(omz, mode="mean", no_pyramid_axis=zarr_config.no_pyramid_axis)
    # logger.info("Write OME-Zarr multiscale metadata")
    # write_ome_metadata(omz, axes=["z", "y", "x"], space_unit=to_ome_unit(unit))
    def print_proc_io():
        try:
            with open("/proc/self/io", "r") as proc_io:
                content = proc_io.read()
                print(content)
        except Exception as e:
            print("Error reading /proc/self/io:", e)

    print_proc_io()
    if not zarr_config.nii:
        logger.info("Conversion complete.")
        return
