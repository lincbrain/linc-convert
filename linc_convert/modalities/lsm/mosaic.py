"""
Convert a collection of tiff files generated by the LSM pipeline into a Zarr.

Example input files can be found at
https://lincbrain.org/dandiset/000004/0.240319.1924/files?location=derivatives%2F
"""

# stdlib
import os
import re
from glob import glob

# externals
import cyclopts
import nibabel as nib
from tifffile import TiffFile

# internals
from linc_convert.modalities.lsm.cli import lsm
from linc_convert.utils.io.zarr import from_config
from linc_convert.utils.orientation import center_affine, orientation_to_affine
from linc_convert.utils.zarr_config import ZarrConfig, update_default_config

mosaic = cyclopts.App(name="mosaic", help_format="markdown")
lsm.command(mosaic)


@mosaic.default
def convert(
        inp: str,
        *,
        zarr_config: ZarrConfig = None,
        max_load: int = 512,
        orientation: str = "coronal",
        center: bool = True,
        thickness: float | None = None,
        voxel_size: list[float] = (1, 1, 1),
        **kwargs
        ) -> None:
    """
    Convert a collection of tiff files generated by the LSM pipeline into ZARR.

    Orientation
    -----------
    The anatomical orientation of the slice is given in terms of RAS axes.

    It is a combination of two letters from the set
    `{"L", "R", "A", "P", "I", "S"}`, where

    * the first letter corresponds to the horizontal dimension and
        indicates the anatomical meaning of the _right_ of the jp2 image,
    * the second letter corresponds to the vertical dimension and
        indicates the anatomical meaning of the _bottom_ of the jp2 image.

    We also provide the aliases

    * `"coronal"` == `"LI"`
    * `"axial"` == `"LP"`
    * `"sagittal"` == `"PI"`

    The orientation flag is only useful when converting to nifti-zarr.

    Parameters
    ----------
    inp
        Path to the root directory, which contains a collection of
        subfolders named `*_z{:02d}_y{:02d}*`, each containing a
        collection of files named `*_plane{:03d}_c{:d}.tiff`.
    out
        Path to the output Zarr directory [<INP>.ome.zarr]
    max_load
        Maximum input chunk size when building pyramid
    orientation
        Orientation of the slice
    center
        Set RAS[0, 0, 0] at FOV center
    voxel_size
        Voxel size along the X, Y and Z dimension, in micron.
    """
    zarr_config = update_default_config(zarr_config, **kwargs)

    if max_load % 2:
        max_load += 1

    CHUNK_PATTERN = re.compile(
            r"^(?P<prefix>\w*)" r"_z(?P<z>[0-9]+)" r"_y(?P<y>[0-9]+)" r"("
            r"?P<suffix>\w*)$"
            )

    all_chunks_dirnames = list(sorted(glob(os.path.join(inp, "*_z*_y*"))))
    all_chunks_info = dict(
            dirname=[],
            prefix=[],
            suffix=[],
            z=[],
            y=[],
            planes=[
                dict(
                        fname=[],
                        z=[],
                        c=[],
                        yx_shape=[],
                        )
                for _ in range(len(all_chunks_dirnames))
                ],
            )

    # parse all directory names
    for dirname in all_chunks_dirnames:
        parsed = CHUNK_PATTERN.fullmatch(os.path.basename(dirname))
        all_chunks_info["dirname"].append(dirname)
        all_chunks_info["prefix"].append(parsed.group("prefix"))
        all_chunks_info["suffix"].append(parsed.group("suffix"))
        all_chunks_info["z"].append(int(parsed.group("z")))
        all_chunks_info["y"].append(int(parsed.group("y")))

    # default output name
    default_name = all_chunks_info["prefix"][0] + all_chunks_info["suffix"][0]
    zarr_config.set_default_name(default_name)

    # parse all individual file names
    nchunkz = max(all_chunks_info["z"])
    nchunky = max(all_chunks_info["y"])
    allshapes = [[(0, 0, 0) for _ in range(nchunky)] for _ in range(nchunkz)]
    nchannels = 0
    dtype = None
    for zchunk in range(nchunkz):
        for ychunk in range(nchunky):
            for i in range(len(all_chunks_info["dirname"])):
                if (
                        all_chunks_info["z"][i] == zchunk + 1
                        and all_chunks_info["y"][i] == ychunk + 1
                ):
                    break
            dirname = all_chunks_info["dirname"][i]
            planes_filenames = list(sorted(glob(os.path.join(dirname, "*.tiff"))))

            PLANE_PATTERN = re.compile(
                    os.path.basename(dirname) + r"_plane(?P<z>[0-9]+)"
                                                r"_c(?P<c>[0-9]+)"
                                                r".tiff$"
                    )

            for fname in planes_filenames:
                parsed = PLANE_PATTERN.fullmatch(os.path.basename(fname))
                all_chunks_info["planes"][i]["fname"] += [fname]
                all_chunks_info["planes"][i]["z"] += [int(parsed.group("z"))]
                all_chunks_info["planes"][i]["c"] += [int(parsed.group("c"))]

                f = TiffFile(fname)
                dtype = f.pages[0].dtype
                yx_shape = f.pages[0].shape
                all_chunks_info["planes"][i]["yx_shape"].append(yx_shape)

            nplanes = max(all_chunks_info["planes"][i]["z"])
            nchannels = max(nchannels, max(all_chunks_info["planes"][i]["c"]))

            yx_shape = set(all_chunks_info["planes"][i]["yx_shape"])
            if not len(yx_shape) == 1:
                raise ValueError("Incompatible chunk shapes")
            yx_shape = list(yx_shape)[0]
            allshapes[zchunk][ychunk] = (nplanes, *yx_shape)

    # check that all chunk shapes are compatible
    for zchunk in range(nchunkz):
        if len(set(shape[1] for shape in allshapes[zchunk])) != 1:
            raise ValueError("Incompatible Y shapes")
    for ychunk in range(nchunky):
        if len(set(shape[ychunk][0] for shape in allshapes)) != 1:
            raise ValueError("Incompatible Z shapes")
    if len(set(shape[2] for subshapes in allshapes for shape in subshapes)) != 1:
        raise ValueError("Incompatible X shapes")

    # compute full shape
    fullshape = [0, 0, 0]
    fullshape[0] = sum(shape[0][0] for shape in allshapes)
    fullshape[1] = sum(shape[1] for shape in allshapes[0])
    fullshape[2] = allshapes[0][0][2]

    omz = from_config(zarr_config)
    arr = omz.create_array("0", shape=[nchannels, *fullshape], dtype="float64",
                           zarr_config=zarr_config)

    print("Write level 0 with shape", [nchannels, *fullshape])
    for i, dirname in enumerate(all_chunks_info["dirname"]):
        chunkz = all_chunks_info["z"][i] - 1
        chunky = all_chunks_info["y"][i] - 1
        planes = all_chunks_info["planes"][i]
        for j, fname in enumerate(planes["fname"]):
            subz = planes["z"][j] - 1
            subc = planes["c"][j] - 1
            yx_shape = planes["yx_shape"][j]

            zstart = sum(shape[0][0] for shape in allshapes[:chunkz])
            ystart = sum(
                    shape[1]
                    for shape in allshapes[chunkz][:chunky]
                    )
            print(
                    f"Write plane "
                    f"({subc}, {zstart + subz}, {ystart}:{ystart + yx_shape[0]})",
                    end="\r",
                    )
            slicer = (
                subc,
                zstart + subz,
                slice(ystart, ystart + yx_shape[0]),
                slice(None),
                )

            f = TiffFile(fname)
            arr[slicer] = f.asarray()
    print("")
    omz.generate_pyramid(mode="median")

    # Write OME-Zarr multiscale metadata
    print("Write metadata")
    omz.write_ome_metadata(["c", "z", "y", "x"], list(map(float, reversed(voxel_size))))

    if not zarr_config.nii:
        print("done.")
        return

    # Write NIfTI-Zarr header
    # NOTE: we use nifti2 because dimensions typically do not fit in a short
    # TODO: we do not write the json zattrs, but it should be added in
    #       once the nifti-zarr package is released
    shape = list(reversed(omz["0"].shape))
    shape = shape[:3] + [1] + shape[3:]  # insert time dimension
    affine = orientation_to_affine(orientation, *voxel_size)
    if center:
        affine = center_affine(affine, shape[:3])
    header = nib.Nifti2Header()
    header.set_data_shape(shape)
    header.set_data_dtype(omz["0"].dtype)
    header.set_qform(affine)
    header.set_sform(affine)
    header.set_xyzt_units(nib.nifti1.unit_codes.code["micron"])
    header.structarr["magic"] = b"nz2\0"
    omz.write_nifti_header(header)
    print("done.")
